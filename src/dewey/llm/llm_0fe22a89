import os
import json
import aiohttp
import asyncio
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

from backend.constants import ChatModel, get_model_string
from backend.api.db_manager import DatabaseManager
from backend.llm.base import EveryLLM


class OpenRouterManager:
    def __init__(self, db_manager: DatabaseManager, daily_limit: int = 1000):
        self.db_manager = db_manager
        self.daily_limit = daily_limit
        self.test_image_url = "https://raw.githubusercontent.com/OpenRouterTeam/openrouter/main/logo.png"
        self.api_key = os.getenv("OPENAI_API_KEY", "your_openrouter_api_key_here")
        self.base_url = "https://openrouter.ai/api/v1"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "HTTP-Referer": "https://github.com/OpenRouterTeam/openrouter",
            "Content-Type": "application/json",
        }

    async def format_vision_message(self, image_url: str) -> List[Dict[str, Any]]:
        return [
            {
                "role": "user",
                "content": [
                    {"type": "text", "text": "What's in this image?"},
                    {"type": "image_url", "image_url": {"url": image_url}},
                ],
            }
        ]

    async def test_model(
        self,
        model: ChatModel,
        test_type: str = "text",
        image_url: Optional[str] = None,
    ) -> Dict[str, Any]:
        model_string = get_model_string(model)
        try:
            # Check rate limit before making the call
            rate_limit_status = await self.get_rate_limit_status(model_string)
            if rate_limit_status["remaining"] <= 0:
                return {
                    "success": False,
                    "error": f"Rate limit exceeded for {model}. Please try again later.",
                }

            # Prepare test message based on type
            if test_type == "vision" and image_url:
                messages = await self.format_vision_message(image_url)
            elif test_type == "code":
                messages = [
                    {
                        "role": "user",
                        "content": "Write a simple Python function to calculate the factorial of a number.",
                    }
                ]
            else:
                messages = [
                    {"role": "user", "content": "Say hello and introduce yourself briefly."}
                ]

            # Make API call
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{self.base_url}/chat/completions",
                    headers=self.headers,
                    json={
                        "model": model_string,
                        "messages": messages,
                    },
                ) as response:
                    response_data = await response.json()
                    status_code = response.status

                    # Log the API call
                    await self.db_manager.log_api_call(
                        endpoint=model_string,
                        request_data=json.dumps({"messages": messages}),
                        response_data=json.dumps(response_data),
                        response_status=status_code,
                    )

                    if status_code == 200:
                        return {"success": True}
                    else:
                        return {
                            "success": False,
                            "error": response_data.get("error", {}).get(
                                "message", "Unknown error"
                            ),
                        }

        except Exception as e:
            return {"success": False, "error": str(e)}

    async def get_available_models(self) -> List[Dict[str, Any]]:
        """Get list of available models and their costs."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.base_url}/models",
                    headers=self.headers,
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get("data", [])
                    else:
                        return []
        except Exception as e:
            print(f"Error fetching available models: {str(e)}")
            return []

    async def get_token_balance(self) -> Dict[str, Any]:
        """Get current token balance."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{self.base_url}/auth/balance",
                    headers=self.headers,
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        return {
                            "available": data.get("data", {}).get("credits", 0),
                            "capacity": self.daily_limit,
                            "used": self.daily_limit - data.get("data", {}).get("credits", 0),
                        }
                    else:
                        return {
                            "available": 0,
                            "capacity": self.daily_limit,
                            "used": self.daily_limit,
                        }
        except Exception as e:
            print(f"Error fetching token balance: {str(e)}")
            return {
                "available": 0,
                "capacity": self.daily_limit,
                "used": self.daily_limit,
            }

    async def get_rate_limit_status(self, model_string: Optional[str] = None) -> Dict[str, Any]:
        """Get current rate limit status."""
        try:
            usage = await self.db_manager.get_api_usage(
                endpoint=model_string if model_string else None,
                since=datetime.now() - timedelta(days=1),
            )
            
            if model_string:
                # Return status for specific model
                model_usage = usage.get(model_string, 0)
                return {
                    "used": model_usage,
                    "limit": self.daily_limit,
                    "remaining": max(0, self.daily_limit - model_usage)
                }
            else:
                # Return status for all models
                return {
                    model: {
                        "used": count,
                        "limit": self.daily_limit,
                        "remaining": max(0, self.daily_limit - count)
                    }
                    for model, count in usage.items()
                }
        except Exception as e:
            print(f"Error getting rate limit status: {str(e)}")
            return {
                "used": 0,
                "limit": self.daily_limit,
                "remaining": self.daily_limit
            } if model_string else {}

    async def get_test_history(self, limit: int = 5) -> List[Dict[str, Any]]:
        """Get recent test history."""
        try:
            return await self.db_manager.get_recent_calls(limit=limit)
        except Exception as e:
            print(f"Error getting test history: {str(e)}")
            return [] 