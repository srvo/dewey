#!/usr/bin/env python3
"""
Migration runner for dewey codebase
This script executes migration scripts generated by codebase_comparison.py
"""

import os
import sys
import logging
import argparse
import glob
import importlib.util
import time
import shutil
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
import traceback

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("migrations.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Constants
MIGRATION_SCRIPTS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "migration_scripts")
BACKUP_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "backup")
OLD_CODEBASE = "/Users/srvo/dewey/old_dewey"
NEW_CODEBASE = "/Users/srvo/dewey/src"

def backup_destination_file(file_path: str) -> bool:
    """Create a backup of the destination file if it exists."""
    if not os.path.exists(file_path):
        return False
    
    backup_path = os.path.join(BACKUP_DIR, os.path.relpath(file_path, NEW_CODEBASE))
    os.makedirs(os.path.dirname(backup_path), exist_ok=True)
    
    try:
        shutil.copy2(file_path, backup_path)
        logger.info(f"Created backup of {file_path} at {backup_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to backup {file_path}: {e}")
        return False

def run_migration_script(script_path: str, dry_run: bool = False) -> Tuple[str, bool, Optional[str]]:
    """Run a single migration script."""
    script_name = os.path.basename(script_path)
    logger.info(f"Running migration script: {script_name}")
    
    if dry_run:
        return script_name, True, "Dry run mode - script not executed"
    
    try:
        # Load the script as a module
        spec = importlib.util.spec_from_file_location("migration_module", script_path)
        if not spec or not spec.loader:
            return script_name, False, "Failed to load script module"
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # Check if the module has a migrate function
        if hasattr(module, 'migrate'):
            # Extract destination file path from the module if available
            destination_path = getattr(module, 'NEW_FILE_PATH', None)
            if destination_path and os.path.exists(destination_path):
                backup_destination_file(destination_path)
            
            # Run the migration
            module.migrate()
            return script_name, True, None
        else:
            return script_name, False, "Script does not have a migrate function"
    
    except Exception as e:
        error_msg = f"Error running {script_name}: {str(e)}\n{traceback.format_exc()}"
        logger.error(error_msg)
        return script_name, False, error_msg

def find_migration_scripts(pattern: Optional[str] = None) -> List[str]:
    """Find all migration scripts in the scripts directory, optionally filtered by pattern."""
    if not os.path.exists(MIGRATION_SCRIPTS_DIR):
        logger.error(f"Migration scripts directory not found: {MIGRATION_SCRIPTS_DIR}")
        return []
    
    if pattern:
        # Check if pattern already contains a .py extension
        if not pattern.endswith('.py'):
            # If the pattern doesn't end with .py, we need to add it
            pattern_with_ext = f"{pattern}.py"
        else:
            pattern_with_ext = pattern
            
        # Try exact match first
        script_paths = glob.glob(os.path.join(MIGRATION_SCRIPTS_DIR, pattern_with_ext))
        
        # If no matches found, try as a substring pattern
        if not script_paths:
            script_paths = glob.glob(os.path.join(MIGRATION_SCRIPTS_DIR, f"*{pattern}*"))
    else:
        script_paths = glob.glob(os.path.join(MIGRATION_SCRIPTS_DIR, "*.py"))
    
    return sorted(script_paths)

def run_migrations(scripts: List[str], dry_run: bool = False, max_workers: int = 1) -> Dict[str, Tuple[bool, Optional[str]]]:
    """Run multiple migration scripts, optionally in parallel."""
    results = {}
    start_time = time.time()
    
    if max_workers > 1:
        logger.info(f"Running {len(scripts)} migrations with {max_workers} parallel workers")
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_script = {
                executor.submit(run_migration_script, script, dry_run): script 
                for script in scripts
            }
            
            for future in as_completed(future_to_script):
                script_name, success, error = future.result()
                results[script_name] = (success, error)
    else:
        logger.info(f"Running {len(scripts)} migrations sequentially")
        for script in scripts:
            script_name, success, error = run_migration_script(script, dry_run)
            results[script_name] = (success, error)
    
    elapsed_time = time.time() - start_time
    logger.info(f"Migration completed in {elapsed_time:.2f} seconds")
    
    return results

def create_migration_report(results: Dict[str, Tuple[bool, Optional[str]]]) -> str:
    """Create a detailed report of migration results."""
    success_count = sum(1 for success, _ in results.values() if success)
    total_count = len(results)
    
    report = [
        "# Migration Report",
        f"\n## Summary",
        f"- Total scripts: {total_count}",
        f"- Successful: {success_count}",
        f"- Failed: {total_count - success_count}",
        f"- Success rate: {(success_count / total_count) * 100:.2f}%\n",
        "\n## Details\n"
    ]
    
    # Successful migrations
    if success_count > 0:
        report.append("### Successful Migrations\n")
        for script_name, (success, _) in sorted(results.items()):
            if success:
                report.append(f"- {script_name}")
    
    # Failed migrations
    if total_count - success_count > 0:
        report.append("\n### Failed Migrations\n")
        for script_name, (success, error) in sorted(results.items()):
            if not success:
                report.append(f"- {script_name}: {error}")
    
    return "\n".join(report)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Run migration scripts for dewey codebase")
    parser.add_argument("--pattern", type=str, help="Pattern to filter migration scripts by name")
    parser.add_argument("--dry-run", action="store_true", help="Don't actually run the migrations, just log what would happen")
    parser.add_argument("--parallel", type=int, default=1, help="Number of parallel migration tasks to run")
    parser.add_argument("--report", type=str, default="migration_report.md", help="Path to save the migration report")
    parser.add_argument("--list-only", action="store_true", help="Only list the scripts that would be run, don't execute them")
    
    args = parser.parse_args()
    
    # Create backup directory
    os.makedirs(BACKUP_DIR, exist_ok=True)
    
    # Find migration scripts
    scripts = find_migration_scripts(args.pattern)
    
    if not scripts:
        logger.error(f"No migration scripts found matching pattern: {args.pattern}")
        return 1
    
    logger.info(f"Found {len(scripts)} migration scripts")
    
    if args.list_only:
        print("\nMigration scripts to run:")
        for script in scripts:
            print(f"  - {os.path.basename(script)}")
        return 0
    
    # Run migrations
    results = run_migrations(scripts, args.dry_run, args.parallel)
    
    # Generate and save report
    report = create_migration_report(results)
    with open(args.report, "w") as f:
        f.write(report)
    
    logger.info(f"Migration report saved to {args.report}")
    
    # Print summary
    success_count = sum(1 for success, _ in results.values() if success)
    print(f"\nMigration completed: {success_count}/{len(results)} successful")
    print(f"See {args.report} for details")
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 