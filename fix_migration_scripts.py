#!/usr/bin/env python3
"""
Fix indentation in migration scripts
Fixes common indentation issues in migration scripts generated by codebase_comparison.py
"""

import os
import sys
import glob
import re
import logging
import argparse
from typing import List, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

MIGRATION_SCRIPTS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "migration_scripts")

def fix_script_direct(script_path: str, dry_run: bool = False) -> Tuple[bool, str]:
    """Fix script by directly rewriting the migrate function with proper syntax."""
    try:
        with open(script_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Look for the file paths in the script
        old_file_path_match = re.search(r'OLD_FILE_PATH\s*=\s*["\'](.*?)["\']', content)
        new_file_path_match = re.search(r'NEW_FILE_PATH\s*=\s*["\'](.*?)["\']', content)
        
        if not old_file_path_match or not new_file_path_match:
            return False, "Could not find file path variables"
        
        # Get the correct template - note we're using a simpler regex pattern
        template = '''
def migrate():
    """Perform the migration from old to new codebase."""
    logger.info(f"Migrating {OLD_FILE_PATH} to {NEW_FILE_PATH}")
    
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(NEW_FILE_PATH), exist_ok=True)
    
    # Migration logic based on analysis
    # New file doesn't exist, copy the old file
    with open(OLD_FILE_PATH, 'r', encoding='utf-8') as f:
        content = f.read()

    # Add BaseScript integration if applicable
    if 'class ' in content and not 'BaseScript' in content:
        content = "from dewey.core.base_script import BaseScript" + "\\n" + content
        # Replace class definitions to inherit from BaseScript
        import re
        # Simple regex to find class definitions
        pattern = 'class ([A-Za-z0-9_]+)\\('
        # Make sure it's not already inheriting from BaseScript
        def replace_class(match):
            class_name = match.group(1)
            if f"class {class_name}(BaseScript" not in content:
                return f"class {class_name}(BaseScript"
            return match.group(0)
        content = re.sub(pattern, replace_class, content)

    with open(NEW_FILE_PATH, 'w', encoding='utf-8') as f:
        f.write(content)

    logger.info(f"Created {NEW_FILE_PATH} based on {OLD_FILE_PATH}")
    logger.info(f"Migration complete for {os.path.basename(OLD_FILE_PATH)}")
'''
        
        # Replace the migrate function
        migrate_pattern = re.compile(r'def migrate\(\):.*?(?=if __name__ == "__main__":|$)', re.DOTALL)
        new_content = migrate_pattern.sub(template, content)
        
        # Make sure the if __name__ block is properly formatted
        if "if __name__ == \"__main__\":" in new_content:
            if not re.search(r'if __name__ == "__main__":\s+migrate\(\)', new_content, re.DOTALL):
                new_content = re.sub(
                    r'if __name__ == "__main__":(.*?)$', 
                    'if __name__ == "__main__":\n    migrate()', 
                    new_content, 
                    flags=re.DOTALL
                )
        
        if dry_run:
            logger.info(f"Would fix {os.path.basename(script_path)}")
            return True, "Dry run - no changes made"
        
        # Write the fixed content
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(new_content)
        
        logger.info(f"Fixed {os.path.basename(script_path)}")
        return True, "Successfully fixed script"
    except Exception as e:
        logger.error(f"Error fixing {script_path}: {e}")
        return False, str(e)

def find_migration_scripts() -> List[str]:
    """Find all migration scripts in the scripts directory."""
    if not os.path.exists(MIGRATION_SCRIPTS_DIR):
        logger.error(f"Migration scripts directory not found: {MIGRATION_SCRIPTS_DIR}")
        return []
    
    script_paths = glob.glob(os.path.join(MIGRATION_SCRIPTS_DIR, "*.py"))
    return sorted(script_paths)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Fix indentation issues in migration scripts")
    parser.add_argument("--dry-run", action="store_true", help="Don't actually modify files, just log what would happen")
    parser.add_argument("--pattern", help="Only process files matching this pattern")
    parser.add_argument("--limit", type=int, help="Limit the number of scripts to process")
    args = parser.parse_args()
    
    scripts = find_migration_scripts()
    
    if args.pattern:
        scripts = [s for s in scripts if args.pattern in os.path.basename(s)]
    
    if args.limit and args.limit > 0:
        scripts = scripts[:args.limit]
    
    if not scripts:
        logger.error("No migration scripts found")
        return 1
    
    logger.info(f"Found {len(scripts)} migration scripts")
    
    fixed_count = 0
    error_count = 0
    
    for i, script_path in enumerate(scripts):
        if i % 100 == 0 and i > 0:
            logger.info(f"Processed {i}/{len(scripts)} scripts")
        
        success, message = fix_script_direct(script_path, args.dry_run)
        
        if success and "Dry run" not in message:
            fixed_count += 1
        elif not success:
            error_count += 1
    
    if args.dry_run:
        logger.info(f"Would fix {fixed_count} scripts")
    else:
        logger.info(f"Fixed {fixed_count} scripts, {error_count} errors")
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 